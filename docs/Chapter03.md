## 목차

- [3장. 함수](#함수)
    
    [가능한 작게 만들어라](#가능한-작게-만들어라)

    [한 가지만 해라](#한-가지만-해라)

    [함수 당 추상화 수준은 하나로](#함수-당-추상화-수준은-하나로)

    [Switch 문](#Switch-문)

    [서술적인 이름을 사용하라](#서술적인-이름을-사용하라)

    [함수 인수](#함수-인수)

- [오늘의 기억하고 싶은 내용](#오늘의-기억하고-싶은-내용)

***

## 함수

### 가능한 작게 만들어라

함수를 만드는 첫째 규칙은 "작게", 둘째 규칙은 "더 작게"이다.

왜 함수를 작게 만들라고 하는 것일까?

이 장에서는 그간의 경험을 통해, 함수가 길어질 수록, 읽기가 힘들고 의도를 명확히 파악하기 어렵다고 하고 있다.

그렇기에 아래의 코드 정도의 길이를 권장하고 있다.

<pre>
<code>
boolean isSuite) throws Exception{
	if(isTestPage(pageData){
    	includeSetupAndTearDownPages(pageData, isSuite);
    }
    return pageData.getHtml(); 
}
<code>
</pre>

또한, if/else 문, while 문 등에 들어가는 블록은 한 줄이어야 한다고 이야기 하고 있다.
중첩 구조가 생길 수록, 읽고 이해하기가 어려워지기 때문이다.

***

### 한 가지만 해라

함수는 한 가지를 해야 한다.   그 한 가지를 잘 해야 한다.   그 한 가지만을 잘 해야한다.

"한 가지"라는 것이 무엇인지 정확히 알기 어렵지만,   이 장에서는 우리에게 추상화 수준이 하나인 단계만 수행한다면, 그 함수는 한 가지 작업만 한다고 말하고 있다.

예시로서, 하나의 페이지를 렌더링 하는 함수 A가 있고, 

이 기능을 하기 위해서 테스트 페이지인지 확인하는 b, 테스트 페이지라면 설정 페이지와 해제 페이즈를 넣는 c, 테스트 페이지든, 아니든 페이지를 렌더링 하는 d가 있다.

그럼 여기서 함수는 b, c, d 라는 세 가지 일을 하는 것이 아닌, 그것들을 추상화 한, A라는 한 가지를 하고 있다고 이야기 한다.

***

### 함수 당 추상화 수준은 하나로

함수가 확실한 한 가지 작업을 수행하려면 함수의 추상화 수준은 모두 동일해야한다.

예를 들어, 한 함수 안에 getHtml();, String pagePathName = PathParser.render(pagepath);, .append("\n"); 같은 코드들이 함께 있다.

이러한 경우,  getHtml();는 추상화 수준이 너무 높고   String pagePathName = PathParser.render(pagepath);는 추상화 수준이 중간이며, .append("\n");는 추상화 수준이 아주 낮다.

이처럼, 추상화 수준이 섞이면, 특정 표현이 근본 개념인지, 세부 사항인지 구분하기 어려워 읽는 사람이 헷갈린다.

또한, 한 번 뒤섞기 시작하면, 뒤이어 사람들이 함수에 세부 사항을 점점 더 추가한다.

그렇기에 추상화 수준은 동일 해야한다.

#### 내려가기 규칙

코드는 위에서 아래로 읽을 때, 이야기 처럼 읽히면 좋다.

이야기 처럼 읽히기 위해서는, 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 오듯이, 아래로 읽을 수록 함수 추상화 수준이 한 번에 한 단계씩 낮아져야 한다.

***

### Switch 문

Switch 문은 작게 만들기 어렵다. 본질적으로 switch 문은 N가지를 처리하기 때문이다.

하지만, 다형성을 이용하여, 각 switch 문을 저차원 클래스에 숨기고 반복하지 않을 수는 있다.

우선, 아래에 직원 유형에 따라 다른 값을 계산하는 예제 함수가 있다.

<pre>
<code>
public Money calculatePay(Employee e)
throws InvalidEmployeeType{
	switch(e.type){
    	case COMMISIONED: 
        	return calculateComissionedPay(e); 
        
        case HOURLY:
        	return calculateHourlyPay(e);
            
        case SALARIED:
        	return calculateSalariedPay(e);
            
        default:
            throw new InvalidEmployeeType(e.type);
    
    }
}
</code>
</pre>

이 함수는 몇 가지 문제를 가지고 있다.

함수가 길며, 직원 유형이 추가될 때, 직원이 수정될 때 함수를 수정해야한다. => OCP(Open Closed Principle) 위반

또한, 한 가지 작업만 수행하지 않고 있다. => SRP(Single Responsibility Principle) 위반

더군다나, 이 함수와 유사한 구조의 함수가 여러개 존재한다면, 더 심각한 문제이다.

그렇기에, 우리는 switch 문을 사용할 때, 이러한 규칙을 염려하고 사용하여야 한다.

***

### 서술적인 이름을 사용하라

함수가 하는 일을 좀 더 잘 표현하는 이름이 곧 좋은 이름이다.

한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 원칙을 달성하기 까지 절반의 성공은 거둔 셈이다.   또한, 함수가 작고 단순할 수록, 서술적인 이름을 고르기는 더욱 쉬워진다.

물론 이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 어려운 이름보다 낫다.

최신 IDE에서는 이름을 바꾸기도 쉽기 때문이다.

그리고 이름을 붙일 때는 유사한 개념끼리는 일관성을, 모듈 내에서 함수 이름은 같은 문구나 명사, 동사를 사용하는 것이 좋다.

아래 예제는 좋은 예이니 참고하자.

- includeSetupAndTeardownPages

- includeSetupPages,

- includeSuiteSetupPage,

- includeSetupPage 등이 있다.

***

### 함수 인수

함수에서 이상적인 인수 개수는 0개이다. 

인수가 늘어갈수록, 읽는 사람이 함수의 개념을 이해하기가 더 어렵기 때문이다.

그러므로 최선은 인수가 없는 경우이며, 다음은 1개, 다음은 2개이고, 3개부터는 가능한 피하는 편이 좋다.

#### 많이 쓰는 단항 형식

함수를 단항 형식으로 쓰는 경우는 흔하게 두 가지가 있다.

하나는 인수에 질문을 던지는 경우다. 마치 boolean fileExists("MyFile"); 처럼 말이다.

다른 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우이다.   InputStream fileOpen("MyFile");코드가 String 형식의 파일 이름을 InputStream으로 바꾸려는 것 처럼 말이다.

#### 플래그 인수

플래그 함수는 여러 개의 일을 처리한다는 뜻이다.

즉, 위에서 설명해오던 법칙들을 위반하는 것이니, 가능한 함수에서 사용하지 말자.

#### 이항 함수

인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다. 

하지만, 이항 함수가 더 적합한 경우도 존재한다. 물론 불가피한 경우도 존재한다.

Point a = new Point(x, y); 처럼 말이다. 이런 경우에 좌표계는 항상 두 값을 취하기에 이항 함수가 적합하다.

***

### 오류 코드보다 예외를 사용하라

 명렴 함수에서 오류 코드를 반환하면 오류 코드를 곧바로 처리해야하는 문제에 직면하게 된다.
 
 자칫하면 오류 코드를 처리하는 if문을 중첩적으로 사용할 수도 있고, 그럴 수록 코드가 지저분해지기 때문이다.

 반면, 오류 코드 대신 예외를 사용하면, 오류 처리 코드가 원래 코드에서 분리되어 코드가 깔끔해진다.

 단, 오류 처리를 함수도 한 가지의 작업만 해야한다

 <pre>
 <code>
 public void delete(Page page){
    try{
    	deletePageAndAllReference(page); 	
    }catch(Exception e){
    	logError(e); 
    }
 }
 
 private void deletePageAndAllReference(Page page) throw Exception{
 	deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey()); 
 }
 </code>
 </pre> 

위 예제에서 delete 함수가 모든 오류를 처리하고, 실제 페이지를 제거하는 함수 deletePageAndAllReference는 예외 처리를 하지 않듯이 말이다.

***

### 반복하지 마라

소프트웨어에서 중복은 악의 근원이라 한다. 대부분의 기법이 중복을 없애거나 제어할 목적으로 나왔기 때문이다.

OOP는 코드를 부모 클래스로 몰아 중복을 없앤다.

예시로, 반복되는 알고리즘 하나가 만약 네 곳에서 사용된다면, 코드 길이가 늘어날 뿐 아니라, 알고리즘이 변하면, 네 곳을 손봐야 한다.

더군다나, 한 곳이라도 빠뜨리면 문제가 발생할 확률도 높다.

그러니, 가능한 한 중복되는 부분에 대해서는 각별히 신경을 써서, 오류가 발생할 확률을 줄이도록 노력을 기울여야 한다.

***

## 오늘의 기억하고 싶은 내용

#### 한 가지만 해라

#### 함수 당 추상화 수준은 하나로

#### 많이 쓰는 단항 형식

#### 플래그 인수라?

플래그 인수는 bool 인수를 말한다. 

render(bool isTest); 처럼 말이다.

플래그 인수를 사용하자마자 함수는 참인지 거짓인지 에 따라 두 가지 일을 해야 한다.

***

### 3장을 돌이켜보며

이번 장을 읽으면서, 단번에 모든 것을 이해하기는 조금 어려운 부분이 있었기도 하고, 문득 떠오른 생각은 조금 다양했던 것 같다.

신경쓰지 않았었던 "함수 당 추상화 수준은 하나로"과 같은 장들은, 이 장을 읽어보며 이러한 부분들을 놓쳤구나 하는 점들은 앞으로 개선해 나가기에 좋은 장이었던 것 같다.

지난 장에 이어, "서술적으로 지어라" 장은 늘 고민하게 되던 이름 짓기에 도움이 될 것 같다는 생각이 들어 감사한 마음이 들었었다.

반면, 지금까지 읽어오며, 어느 것이 더 나을까 하는 고민이 든 부분도 있었다. 주석 처리와 같은 부분들에 대해서는 이름으로 모든걸 설명하기 어렵지 않나 싶은 생각이 남아있기에, 4장인 주석 파트에 고민을 이어가볼 것 같다.

***

## 해시태그 ##
#코딩 #개발자 #노마드코더 #북클럽 #노개북

***

## 작성시기 ##
2022.04.26

***